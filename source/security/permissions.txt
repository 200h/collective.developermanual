==================
 Permissions
==================

.. admonition:: Description

    How to deal with permissions making your code permission aware in Plone

.. contents :: :local:

Introduction
------------

Permissions control whether the logged in / anonymous users can execute code paths.

Permission check is done for

* For every view/method which is hit by incoming HTTP request (Plone automatically exports
  traversable methods over HTTP interface) 

* For every called method for :doc:`RestrictedPython scripts </security/sandboxing>`

The basic way of dealing with permissions is setting the ``permission`` attribute
of view declaration. For more information see :doc:`views </views/browserviews>`_.

Checking permission manually
----------------------------

The following code checks whether the logged in user
has a certain permission for the some object.

.. code-block:: python

    from AccessControl import getSecurityManager
    from AccessControl import Unauthorized

    # Import permission names as pseudo-constants strings from somewhere... see security doc for more info
    from Products.CMFCore import permissions

    def some_function(self, object):


        # This will
        if not getSecurityManager().checkPermission(permissions.ModifyPortalContent, object):
            raise Unauthorized("You need ModifyPortalContent permission to edit header animations")

         # ...
         # we have security clearance here
         #

Bypassing permission checks
---------------------------

The current user is defined by active security manager. In both restricted and unrestricted execution certain 
functions may do their own security checks (invokeFactory, workflow, search)
to filter out results. 

If function does its own security check, there usually a code path to execute without security check.
For example the methods below have security-aware and raw versions

* context.restrictedTraverse() vs. context.unrestrictedTraverse()

* portal_catalog.searchResults() vs. portal_catalog.unrestrictedSearchResults()

However, in certain situations you have only security-aware code path
which is blocked for the current user. You still want to execute
this code path and you are sure that it does not violate your site 
security principles. 

Below is an example how you can call any Python function and
work around the security checks by establishing a temporary
``AccessControl.SecurityManager`` under special role. 

Example::

	from AccessControl import ClassSecurityInfo, getSecurityManager
	from AccessControl.SecurityManagement import newSecurityManager, setSecurityManager
	from AccessControl.User import nobody
	from AccessControl.User import UnrestrictedUser as BaseUnrestrictedUser
	
	class UnrestrictedUser(BaseUnrestrictedUser):
	    """Unrestricted user that still has an id.
	    """
	    def getId(self):
	        """Return the ID of the user.
	        """
	        return self.getUserName()
	
	def execute_under_special_role(portal, role, function, *args, **kwargs):
	    """ Execute code under special role priviledges.
	    
	    Example how to call::
	    
	    	execute_under_special_role(portal, "Manager", 
	            doSomeNormallyNotAllowedStuff,
	            source_folder, target_folder)
	    	
	    
	    @param portal: Reference to ISiteRoot object whose access controls we are using
	    
	    @param function: Method to be called with special priviledges
	    
	    @param role: User role we are using for the security context when calling the priviledged code. For example, use "Manager".
	    
	    @param args: Passed to the function
	    
	    @param kwargs: Passed to the function 
	    """
	    
	    sm = getSecurityManager()
	    
	    try:
	        try:
	            
	            # Clone the current access control user and assign a new role for him/her
	            # Note that the username (getId()) is left in exception tracebacks in error_log
	            # so it is important thing to store 
	            tmp_user = UnrestrictedUser(
	              sm.getUser().getId(),
	               '', [role], 
	               ''
	           )
	          
	            # Act as user of the portal
	            tmp_user = tmp_user.__of__(portal.acl_users)
	            newSecurityManager(None, tmp_user)
	            
	            # Call the function
	            return function(*args, **kwargs)
	            
	        except:
	            # If special exception handlers are needed, run them here
	            raise
	    finally:
	        # Restore the old security manager
	        setSecurityManager(sm)    

For more information, see 

* http://github.com/ned14/Easyshop/blob/master/src/easyshop.order/easyshop/order/adapters/order_management.py

Catching Unauthorized
---------------------

Gracefully failing when the user does not have a permission. Example::

        from AccessControl import Unauthorized

        try:
            portal_state = context.restrictedTraverse("@@plone_portal_state")
        except Unauthorized:
            # portal_state may be limited to admin users only
            portal_state = None


Creating permissions
--------------------

You don't create permissions, they "spring into existence".
Whatever that means.

* http://pypi.python.org/pypi/collective.autopermission/1.0b1 (Plone 3 only)

* http://n2.nabble.com/creating-and-using-your-own-permissions-in-Plone-3-tp339972p1498626.html

* http://blog.fourdigits.nl/adding-zope-2-permissions-using-just-zcml-and-a-generic-setup-profile

Assigning permissions to users (roles)
--------------------------------------

Permissions are usually assigned to roles, which are assigned to users through
the web.

To assign a permission to a role, use profiles/default/rolemap.xml:

.. code-block:: xml

   <?xml version="1.0"?>
    <rolemap>
      <permissions>
        <permission name="MyProduct: MyPermission" acquire="False">
          <role name="Member"/>
        </permission>
      </permissions>
    </rolemap> 


Manually fix permission problems
--------------------------------

In the case you fiddle with permission and manage lock out even admin user for the content (both Plone
page and raw Zope page) you can still fix the problem from :doc:`debug prompt </misc/commandline>`.

Example debug session how to set ``Access Contents Information`` back to all users::

        >>> j=app.yoursiteid.yourfolderid.problematiccontent 
        >>> import AccessControl
        >>> import Products.CMFCore.permissions
        >>> sm=AccessControl.getSecurityManager()
        >>> import transaction
        >>> anon=sm.getUser()
        >>> j.manage_permission(Products.CMFCore.permissions.AccessContentsInformation,roles=anon.getRoles())
        >>> transaction.commit()