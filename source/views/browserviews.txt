===============
 Browser views
===============

BrowserView classes are a combination of Python object-oriented class code and
page template to produce a HTML page. By keeping as much of the logic code
in a separate Python class and making page template as dump as possible
the code readability and reuse is achieved.

`Read Zope view tutorial <http://plone.org/documentation/tutorial/borg/zope-3-views>`_.

Each BrowserView class is callable. BrowserView.__call__()
method acts as an entry point of executing the view code.

Usually BrowserView have also index attribute which
is instance of ViewPageTemplateFile class. 
If BrowserView.__call__() is not overridden, it will
return the value of self.index() call.

Creating a view
---------------

Example::

    # We must use BrowserView from view, not from zope.browser
    # Zope version does not
    from Products.Five.browser import BrowserView

    class MyView(BrowserView):

        def __init__(self, context, request):
            self.context = context
            self.requet = request

        # by default call will call self.index() method which is mapped
        # to ViewPageTemplateFile specified in ZCML
        #def __call__():
        #

Zope ViewPageTemplateFile vs. Five ViewPageTemplateFile
-------------------------------------------------------

.. *warning*: There are two ViewPageTemplateFile classes with the same name.

* Zope  `BrowserView source code <http://svn.zope.org/zope.publisher/trunk/src/zope/publisher/browser.py?rev=101538&view=auto>`_.

* `Five version  <http://svn.zope.org/Zope/trunk/src/Products/Five/browser/__init__.py?rev=96262&view=markup>`_. Products.Five is a way
  to stick some of Zope 3 technologies to Zope 2 codebase used by Plone.

Difference in code::

    from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
    
    vs.
    
    from zope.app.pagetemplate import ViewPageTemplateFile
        

Difference is that Five version supports

* Acquisition

* provider: TAL expression

* Other Plone specific TAL expression functions like test()

* Usually Plone code needs Five version of ViewPageTemplateFile

* Some components, no    ly z3c.form, expect Zope 3 version of ViewPageTemplateFile 

Relationship between views and templates
----------------------------------------

ZCML <browser:view template=""> will set *index* class attribute.

The default view __call__() method will return the value
returned by self.index() call.

Eaxmple::
    
    <browser:page
        for="*"
        name="test"
        permission="zope2.Public"
        class=".views.MyView"        
        />    
    
    from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile

    class MyView(BrowserView):
    
        index = ViewPageTemplateFile("my-template.pt") 


is equal to::

    <browser:page
        for="*"
        name="test"
        permission="zope2.Public"
        class=".views.MyView"
        template="my-template.pt"        
        />   

    class MyView(BrowserView):
        pass
        
Rendering of the view is done by following:

    class MyView(BrowserView):
        
        # This may be overridden in ZCML
        index = ViewPageTemplateFile("my-template.pt")
    
        def render(self):
            return self.index()
    
        def __call__(self):
            return self.render()

Getting a view by id
--------------------

Below is an example how to resolve a view for any contentish object
using traverse. View is also put into acquisition chain using __of__()
method (necessary for rendering Plone templates).

Example::

    def getView(context, name):
        """ Return a view which is associated with context object and current HTTP request.

        @param context: Any Plone content object
        @param name: Attribute name holding the view name
        """


        try:
            view = context.unrestrictedTraverse("@@" + name)
        except AttributeError:
            raise RuntimeError("Instance %s did not have view %s" % (str(context), name))

        view = view.__of__(context)

        return view
        
View helpers
-------------

You usually need access parts of Plone config and user session data
from your view.

Here are some useful tips how to do it.

IPortalState and IContextState
==============================

IPortalState define IContextState view-like interfaces
to access miscencancellous information useful for the 
current page render. The views are cached properly,
so they should access the information quite effective manner

To see what's available through the interface,
read documentation in  
`plone.app.layout.globals.interfaces <https://svn.plone.org/svn/plone/plone.app.layout/trunk/plone/app/layout/globals/interfaces.py>`_
module.

Example how to get the current language::

	from Acquisition import aq_inner
	from zope.component import getMultiAdapter

    context = aq_inner(self.context)
    portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
    
    current_language = portal_state.language()
        
Example how to expose porta_state to template::

ZCML includes allowed_attributes::

    <browser:page
        for="*"
        name="test"
        permission="zope2.Public"
        class=".views.MyView"
        allowed_attributes="portal_state"
        />
        

Python class exposes the variable.

	from Acquisition import aq_inner
	from zope.component import getMultiAdapter

             
    class MyView(BrowserView):
        
		@propert
		def portal_state(self):
		    context = aq_inner(self.context)
		    portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
		    return portal_state
		    
Template can use it:

	<div>
		The language is <span tal:content="view/portal_state/language" /> 
	</div>
	
You can directly look up portal_state in template using acquisition 
magic and view traversing, without need of ZCML code
or Python view code changes. This is useful e.g. overridden
viewlet templates::

	<!--
	
		In traversing @@ marks that the traversing
		machine should look up a view by that name.
		
		First we look up the view and then use 
		it to access the variables defined in 
		IPortalState interface.
		
	-->

	<div tal:define="portal_state context/@@plone_portal_state" >
		The language is <span tal:content="portal_state/language" /> 
	</div>
	
			    
Tools 
======

Tools are persistent utility classes available in the site root.
They are visible in ZMI. Tools include things like

* portal_catalog - Search and indexing facilities for content

* portal_workflow - Inquiry and do workflow related actions

* portal_membership - User registration information


ITools interface
++++++++++++++++

`plone.app.layout.globals.interfaces.ITools interface <https://svn.plone.org/svn/plone/plone.app.layout/trunk/plone/app/layout/globals/interfaces.py>`_
and Tools BrowserView provide cached access for most often 
needed tools.

Example::

	from Acquisition import aq_inner
	from zope.component import getMultiAdapter

    context = aq_inner(self.context)
	tools = getMultiAdapter((context, self.request), name=u'plone_tools') 
	
	portal_url = tools.url()
	
	# The root URL of the site is got by using portal_url.__call__()
	# method
	
	the_current_root_url_of_the_site = portal_url() 	

getToolByName
+++++++++++++

getToolByName is old-fashioned way of getting tools the context
object as a start point. It also works for tools
which are not defined in ITools interface.

getToolByName gets any Plone portal root item using acquisition.

Example::

    from Products.CMFCore.WorkflowCore import WorkflowException
    
	# Do the workflow transition "submit" for the current context
    workflowTool = getToolByName(self.context, "portal_workflow")
	workflowTool.doActionFor(self.context, "submit")

