===================
Functional testing
===================

.. contents ::

Introduction
------------

PloneTestCase product provides `FunctionalTestCase <https://svn.plone.org/svn/collective/Products.PloneTestCase/trunk/Products/PloneTestCase/PloneTestCase.py>`_
base class for functional testing. Unlike unit tests, functional tests simulate real HTTP requests with transaction life cycle.

* Functional tests has different transaction for each browser.open() request

* Functional tests do traversing and can check e.g. for cookie based permissions

* Unit test method is executed in a single transaction and this might make impossible to
  test cache related behavior

Test browser
------------

Plone uses Products.Five.testbrowser as an browser emulator used in functional tests.
It is based on zope.testbrowser package.
For available API see `zope.testbrowser home page <http://pypi.python.org/pypi/zope.testbrowser>`_.

.. warning::

    There also exists old `zc.testbrowser <http://pypi.python.org/pypi/zc.testbrowser>`_,
    which is a different package with similar name.

All code assumes here is is executed in unit test context where self.portal is your unit test site instance.

Recording tests
----------------

You can record functional tests through the browser. Think it as a Microsoft Word macro recoder kind of thing.

* http://plone.org/documentation/kb/testing/zope-testrecorder

* http://pyyou.wordpress.com/2008/04/11/how-to-install-zopetestrecorder-with-buildout/

* http://pypi.python.org/pypi/zope.testrecorder

Functional test skeleton
------------------------

First see collective.testlayer package which does some of the things 
described below

* http://pypi.python.org/pypi/collective.testcaselayer

Example code::

    from Products.Five.testbrowser import Browser
    from Products.PloneTestCase import PloneTestCase as ptc

    class BaseFunctionalTestCase(ptc.FunctionalTestCase):
        """ This is a base class for functional test cases for your custom product.
        """

        def afterSetUp(self):
            """
            Show errors in console by monkey patching site error_log service
            """

            ptc.FunctionalTestCase.afterSetUp(self)

            self.browser = Browser()
            self.browser.handleErrors = False # Don't get HTTP 500 pages


            self.portal.error_log._ignored_exceptions = ()

            def raising(self, info):
                import traceback
                traceback.print_tb(info[2])
                print info[1]

            from Products.SiteErrorLog.SiteErrorLog import SiteErrorLog
            SiteErrorLog.raising = raising


        def loginAsAdmin(self):
            """ Perform through-the-web login.

            Simulate going to the login form and logging in.

            We use username and password provided by PloneTestCase.

            This sets session cookie for testbrowser.
            """
            from Products.PloneTestCase.setup import portal_owner, default_password

            # Go admin
            browser = self.browser
            browser.open(self.portal.absolute_url() + "/login_form")
            browser.getControl(name='__ac_name').value = portal_owner
            browser.getControl(name='__ac_password').value = default_password
            browser.getControl(name='submit').click()

Preparing error logger
----------------------

Since zope.testbrowser uses normal Plone paging mechanism, you won't get nice tracebacks to your console.

The following snippet allows you to extract traceback data from site.error_log utility and print it to the console.
Put it to your afterSetUp()::

        self.browser.handleErrors = False
        self.portal.error_log._ignored_exceptions = ()

        def raising(self, info):
            import traceback
            traceback.print_tb(info[2])
            print info[1]

        from Products.SiteErrorLog.SiteErrorLog import SiteErrorLog
        SiteErrorLog.raising = raising

Opening an URL
--------------

Example::

    from Products.Five.testbrowser import Browser

    self.browser = Browser()

    self.browser.open(self.portal.absolute_url())

Logging in
----------

Example::

        from Products.PloneTestCase.setup import portal_owner, default_password

         # Go admin
        browser.open(self.portal.absolute_url() + "/login_form")
        browser.getControl(name='__ac_name').value = portal_owner
        browser.getControl(name='__ac_password').value = default_password
        browser.getControl(name='submit').click()

Showing the contents of current 
-------------------------------

After test browser has opened an URL its
content can be read from broser.contents variable.

Example::

    print browser.contents # browser is z3c.testbrowser.Browser instance

Listing available form controls
-------------------------------

Cannot be done. Check available controls from the form source code.

Selecting a checkbox
--------------------

Checkboxes are usually presented as name:list style names::

    checkbox = form.getControl(name="myitem.select:list")
    checkbox.value = [u"selected"]

Clicking a button
-----------------

Example::

    button = form.getControl(name="mybuttonname")
    button.click()
    
Checking Unauthorized response
------------------------------

Example::

    def checkIsUnauthorized(self, url):
        """
        Check whether URL gives Unauthorized response. 
        """
        
        import urllib2 
        
        # Disable redirect on security error
        self.portal.acl_users.credentials_cookie_auth.login_path = ""
        
        # Unfuse exception tracking for debugging
        # as set up in afterSetUp()
        self.browser.handleErrors = True
        
        def raising(self, info):
            pass
        self.portal.error_log._ignored_exceptions = ("Unauthorized")
        from Products.SiteErrorLog.SiteErrorLog import SiteErrorLog
        SiteErrorLog.raising = raising
        
        try:
            self.browser.open(url)
            raise AssertionError("No Unauthorized risen:" + url)
        except urllib2.HTTPError,  e:
            # Mechanize, the engine under testbrowser
            # uses urlllib2 and will raise this exception
            self.assertEqual(e.code, 401, "Got HTTP response code:" + str(e.code))

Checking a HTTP response header
--------------------------------

Exaple:

        self.assertEqual(self.browser.headers["Content-type"], 'application/octet-stream')  

Checking HTTP exception
-------------------------

Example how to check for HTTP 500 Internal Server Error::

    def test_no_language(self):
        """ Check that language parameter is needed and nothing is executed unless it is given. """
        
        from urllib2 import HTTPError
        try:
            self.browser.handleErrors = True # Don't get HTTP 500 pages
            url = self.portal.absolute_url() + "/@@mobile_sitemap?mode=mobile"
            self.browser.open(url)
            # should cause HTTPError: HTTP Error 500: Internal Server Error
            raise AssertionError("Should be never reached")
        except HTTPError, e:
            pass      

Setting test browser headers
-----------------------------

Headers must be passed to underlying PublisherMechanizeBrowser instance
and test browser must be constructed based on this instance.

.. note ::

        When passing parameters to PublisherMechanizeBrowser.addheaders HTTP_ prefix will be automatically added
        to header name.

Setting user agent
=====================

Example::


    class BaseFunctionalTestCase(ptc.FunctionalTestCase):

        def setUA(self, user_agent):
            """
            Create zope.testbrowser Browser with a specific user agent.
            """

            # Be sure to use Products.Five.testbrowser here
            self.browser = UABrowser(user_agent)
            self.browser.handleErrors = False # Don't get HTTP 500 pages

    from zope.testbrowser import browser
    from Products.Five.testbrowser import PublisherHTTPHandler
    from Products.Five.testbrowser import PublisherMechanizeBrowser

    class UABrowser(browser.Browser):
        """A Zope ``testbrowser` Browser that uses the Zope Publisher.

        The instance must set a custom user agent string.
        """

        def __init__(self, user_agent, url=None):

            mech_browser = PublisherMechanizeBrowser()
            mech_browser.addheaders = [("User-agent", user_agent),]

            # override the http handler class
            mech_browser.handler_classes["http"] = PublisherHTTPHandler
            browser.Browser.__init__(self, url=url, mech_browser=mech_browser)




For more information, see

* https://mail.zope.org/pipermail/zope3-users/2008-May/007871.html

